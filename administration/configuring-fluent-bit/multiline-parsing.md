# Multiline parsing

In an ideal world, applications might log their messages within a single line, but in reality applications generate multiple log messages that sometimes belong to the same context. Processing this information can be complex, like in application stack traces, which always have multiple log lines.

Fluent Bit v1.8 implemented a unified Multiline core capability to solve corner cases.

## Concepts

The Multiline parser engine exposes two ways to configure and use the feature:

- Built-in multiline parser
- Configurable multiline parser

### Built-in multiline parsers

Fluent Bit exposes certain pre-configured parsers (built-in) to solve specific multiline parser cases. For example:

| Parser | Description |
| ------ | ----------- |
| `docker` | Process a log entry generated by a Docker container engine. This parser supports the concatenation of log entries split by Docker.      |
| `cri` | Process a log entry generated by CRI-O container engine. Like the `docker` parser, it supports concatenation of log entries.          |
| `go`     | Process log entries generated by a Go based language application and perform concatenation if multiline messages are detected.          |
| `python` | Process log entries generated by a Python based language application and perform concatenation if multiline messages are detected.      |
| `java`   | Process log entries generated by a Google Cloud Java language application and perform concatenation if multiline messages are detected. |

### Configurable multiline parsers

You can define your own Multiline parsers with their own rules, using a configuration file.

A multiline parser is defined in a `parsers configuration file` by using a `[MULTILINE_PARSER]` section definition. The multiline parser must have a unique name and a type, plus other configured properties associated with each type.

To understand which multiline parser type is required for your use case you have to know the conditions in the content that determine the beginning of a multiline message, and the continuation of subsequent lines. Fluent Bit provides a regular expression-based configuration that supports states to handle from the most cases.

| Property | Description | Default |
| -------- | ----------- | ------- |
| `name` | Specify a unique name for the multiline parser definition. A good practice is to prefix the name with the word `multiline_` to avoid confusion with normal parser definitions. | _none_ |
| `type`          | Set the multiline mode. Fluent Bit supports the type `regex`.| _none_ |
| `parser`        | Name of a pre-defined parser that must be applied to the incoming content before applying the regular expression rule. If no parser is defined, it's assumed that's a raw text and not a structured message. When a parser is applied to a raw text, the regular expression is applied against a specific key of the structured message by using the `key_content` configuration property. | _none_ |
| `key_content`   | For an incoming structured message, specify the key that contains the data that should be processed by the regular expression and possibly concatenated. | _none_ |
| `flush_timeout` | Timeout in milliseconds to flush a non-terminated multiline buffer. | `5s` |
| `rule`          | Configure a rule to match a multiline pattern. The rule has a [specific format](#rules-definition). Multiple rules can be defined. | _none_|

#### Lines and states

Before configuring your parser you need to know the answer to the following questions:

1. What's the regular expression (`regex`) that matches the first line of a multiline message?
1. What are the regular expressions (`regex`) that match the continuation lines of a multiline message?

When matching a regular expression, you must to define `states`. Some states define the start of a multiline message while others are states for the continuation of multiline messages. You can have multiple `continuation states` definitions to solve complex cases.

The first regular expression that matches the start of a multiline message is called `start_state`. Other regular expression continuation lines can have different state names.

#### Rules definition

A rule specifies how to match a multiline pattern and perform the concatenation. A rule is defined by 3 specific components:

- state name
- regular expression pattern
- next state

A rule might be defined as follows (comments added to simplify the definition) in corresponding YAML and classic configuration examples below:

{% tabs %}
{% tab title="parsers_multiline.yaml" %}

```yaml
# rules |   state name  | regex pattern                  | next state
# ------|---------------|--------------------------------------------
rules:
  - state: start_state
    regex: '/([a-zA-Z]+ \d+ \d+\:\d+\:\d+)(.*)/'
    next_state:  cont
  - state: cont
    regex: '/^\s+at.*/'
    next_state: cont
```

{% endtab %}

{% tab title="parsers_multiline.conf" %}

```text
# rules   |   state name   | regex pattern                   | next state
# --------|----------------|---------------------------------------------
rule         "start_state"   "/([a-zA-Z]+ \d+ \d+\:\d+\:\d+)(.*)/"   "cont"
rule         "cont"          "/^\s+at.*/"                      "cont"
```

{% endtab %}
{% endtabs %}

This example defines two rules. Each rule has its own state name, regular expression patterns, and the next state name. Every field that composes a rule must be inside double quotes.

The first rule of a state name must be `start_state`. The regular expression pattern must match the first line of a multiline message, and a next state must be set to specify what the possible continuation lines look like.

{% hint style="info" %}
To simplify the configuration of regular expressions, you can use the [Rubular](https://rubular.com/r/NDuyKwlTGOvq2g) web site. This link uses the regular expression described in the previous example, plus a log line that matches the pattern:
{% endhint %}

#### Configuration example

The following example provides a full Fluent Bit configuration file for multiline parsing by using the definition  explained previously. It is provided in corresponding YAML and classic configuration examples below:

{% tabs %}

{% tab title="fluent-bit.yaml" %}

This is the primary Fluent Bit YAML configuration file. It includes the `parsers_multiline.yaml` and tails the file `test.log`  by applying the multiline parser `multiline-regex-test`. Then it sends the processing to the standard output.

```yaml
service:
    flush: 1
    log_level: info
    parsers_file: parsers_multiline.yaml

pipeline:
    inputs:
      - name: tail
        path: test.log
        read_from_head: true
        multiline.parser: multiline-regex-test

    outputs:
      - name: stdout
        match: '*'
```

{% endtab %}

{% tab title="fluent-bit.conf" %}

This is the primary Fluent Bit classic configuration file. It includes the `parsers_multiline.conf` and tails the file `test.log`  by applying the multiline parser `multiline-regex-test`. Then it sends the processing to the standard output.

```text
[SERVICE]
    flush        1
    log_level    info
    parsers_file parsers_multiline.conf

[INPUT]
    name             tail
    path             test.log
    read_from_head   true
    multiline.parser multiline-regex-test

[OUTPUT]
    name             stdout
    match            *
```

{% endtab %}

{% tab title="parsers_multiline.yaml" %}

This file defines a multiline parser for the YAML configuration example.

```yaml
multiline_parsers:
    - name: multiline-regex-test
      type: regex
      flush_timeout: 1000
      #
      # Regex rules for multiline parsing
      # ---------------------------------
      #
      # configuration hints:
      #
      #  - first state always has the name: start_state
      #  - every field in the rule must be inside double quotes
      #
      # rules |   state name  | regex pattern                  | next state
      # ------|---------------|--------------------------------------------
      rules:
        - state: start_state
          regex: '/([a-zA-Z]+ \d+ \d+\:\d+\:\d+)(.*)/'
          next_state: cont
        - state: cont
          regex: '/^\s+at.*/'
          next_state: cont
```


{% endtab %}

{% tab title="parsers_multiline.conf" %}

This second file defines a multiline parser for the classic configuration example.

```text
[MULTILINE_PARSER]
    name          multiline-regex-test
    type          regex
    flush_timeout 1000
    #
    # Regex rules for multiline parsing
    # ---------------------------------
    #
    # configuration hints:
    #
    #  - first state always has the name: start_state
    #  - every field in the rule must be inside double quotes
    #
    # rules |   state name  | regex pattern                  | next state
    # ------|---------------|--------------------------------------------
    rule      "start_state"   "/([a-zA-Z]+ \d+ \d+\:\d+\:\d+)(.*)/"  "cont"
    rule      "cont"          "/^\s+at.*/"                     "cont"
```

{% endtab %}

{% tab title="test.log" %}

The example log file with multiline content:

```text
single line...
Dec 14 06:41:08 Exception in thread "main" java.lang.RuntimeException: Something has gone wrong, aborting!
    at com.myproject.module.MyProject.badMethod(MyProject.java:22)
    at com.myproject.module.MyProject.oneMoreMethod(MyProject.java:18)
    at com.myproject.module.MyProject.anotherMethod(MyProject.java:14)
    at com.myproject.module.MyProject.someMethod(MyProject.java:10)
    at com.myproject.module.MyProject.main(MyProject.java:6)
another line...

```

{% endtab %}
{% endtabs %}

By running Fluent Bit with the corresponding configuration file you will obtain the following output:

```text
# For YAML configuration.
$ ./fluent-bit --config fluent-bit.yaml

# For classic configuration.
$ ./fluent-bit --config fluent-bit.conf

...
[0] tail.0: [[1750332967.679671000, {}], {"log"=>"single line...
"}]
[1] tail.0: [[1750332967.679677000, {}], {"log"=>"Dec 14 06:41:08 Exception in thread "main" java.lang.RuntimeException: Something has gone wrong, aborting!
    at com.myproject.module.MyProject.badMethod(MyProject.java:22)
    at com.myproject.module.MyProject.oneMoreMethod(MyProject.java:18)
    at com.myproject.module.MyProject.anotherMethod(MyProject.java:14)
    at com.myproject.module.MyProject.someMethod(MyProject.java:10)
    at com.myproject.module.MyProject.main(MyProject.java:6)
"}]
[2] tail.0: [[1750332967.679677000, {}], {"log"=>"another line...
"}]
```

The lines that didn't match a pattern aren't considered as part of the multiline message, while the ones that matched the rules were concatenated properly.

## Limitations

The multiline parser is a very powerful feature, but it has some limitations that you should be aware of:

- The multiline parser isn't affected by the `buffer_max_size` configuration option, allowing the composed log record to grow beyond this size. The `skip_long_lines` option won't be applied to multiline messages.
- It's not possible to get the time key from the body of the multiline message. However, it can be extracted and set as a new key by using a filter.

## Get structured data from multiline message

Fluent-bit supports the `/pat/m` option. It allows `.` matches a new line, which can be used to parse multiline logs.

The following example retrieves `date` and `message` from concatenated logs.

Example files content:

{% tabs %}

{% tab title="fluent-bit.yaml" %}

This is the primary Fluent Bit YAML configuration file. It includes the `parsers_multiline.conf` and tails the file `test.log`  by applying the multiline parser `multiline-regex-test`. It also parses concatenated log by applying parser `named-capture-test`.  Then it sends the processing to the standard output.

```yaml
service:
    flush: 1
    log_level: info
    parsers_file: parsers_multiline.yaml

pipeline:
    inputs:
      - name: tail
        path: test.log
        read_from_head: true
        multiline.parser: multiline-regex-test

    filters:
      - name: parser
        match: '*'
        key_name: log
        parser: named-capture-test

    outputs:
      - name: stdout
        match: '*'
```

{% endtab %}

{% tab title="fluent-bit.conf" %}

This is the primary Fluent Bit classic configuration file. It includes the `parsers_multiline.conf` and tails the file  `test.log` by applying the multiline parser `multiline-regex-test`. It also parses concatenated log by applying parser  `named-capture-test`. Then it sends the processing to the standard output.

```text
[SERVICE]
    flush        1
    log_level    info
    parsers_file parsers_multiline.conf

[INPUT]
    name             tail
    path             test.log
    read_from_head   true
    multiline.parser multiline-regex-test

[FILTER]
    name             parser
    match            *
    key_name         log
    parser           named-capture-test

[OUTPUT]
    name             stdout
    match            *
```

{% endtab %}

{% tab title="parsers_multiline.yaml" %}

This file defines a multiline parser for the YAML example.

```yaml
multiline_parsers:
    - name: multiline-regex-test
      type: regex
      flush_timeout: 1000
      #
      # Regex rules for multiline parsing
      # ---------------------------------
      #
      # configuration hints:
      #
      #  - first state always has the name: start_state
      #  - every field in the rule must be inside double quotes
      #
      # rules |   state name  | regex pattern                  | next state
      # ------|---------------|--------------------------------------------
      rules:
        - state: start_state
          regex: '/([a-zA-Z]+ \d+ \d+\:\d+\:\d+)(.*)/'
          next_state:  cont
        - state: cont
          regex: '/^\s+at.*/'
          next_state: cont

parsers:
    - name: named-capture-test
      format: regex
      regex: '/^(?<date>[a-zA-Z]+ \d+ \d+\:\d+\:\d+) (?<message>.*)/m'
 ```

{% endtab %}

{% tab title="parsers_multiline.conf" %}

This file defines a multiline parser for the classic example.

```text
[MULTILINE_PARSER]
    name          multiline-regex-test
    type          regex
    flush_timeout 1000
    #
    # Regex rules for multiline parsing
    # ---------------------------------
    #
    # configuration hints:
    #
    #  - first state always has the name: start_state
    #  - every field in the rule must be inside double quotes
    #
    # rules |   state name  | regex pattern                  | next state
    # ------|---------------|--------------------------------------------
    rule      "start_state"   "/([a-zA-Z]+ \d+ \d+\:\d+\:\d+)(.*)/"  "cont"
    rule      "cont"          "/^\s+at.*/"                     "cont"

[PARSER]
    Name named-capture-test
    Format regex
    Regex /^(?<date>[a-zA-Z]+ \d+ \d+\:\d+\:\d+) (?<message>.*)/m
```

{% endtab %}

{% tab title="test.log" %}

The example log file with multiline content:

```text
single line...
Dec 14 06:41:08 Exception in thread "main" java.lang.RuntimeException: Something has gone wrong, aborting!
    at com.myproject.module.MyProject.badMethod(MyProject.java:22)
    at com.myproject.module.MyProject.oneMoreMethod(MyProject.java:18)
    at com.myproject.module.MyProject.anotherMethod(MyProject.java:14)
    at com.myproject.module.MyProject.someMethod(MyProject.java:10)
    at com.myproject.module.MyProject.main(MyProject.java:6)
another line...

```

{% endtab %}
{% endtabs %}

By running Fluent Bit with the corresponding configuration file you will obtain:

```text
# For YAML configuration.
$ ./fluent-bit --config fluent-bit.yaml

# For classic configuration
$ ./fluent-bit --config fluent-bit.conf

[0] tail.0: [[1750333602.460984000, {}], {"log"=>"single line...
"}]
[1] tail.0: [[1750333602.460998000, {}], {"date"=>"Dec 14 06:41:08", "message"=>"Exception in thread "main" java.lang.RuntimeException: Something has gone wrong, aborting!
    at com.myproject.module.MyProject.badMethod(MyProject.java:22)
    at com.myproject.module.MyProject.oneMoreMethod(MyProject.java:18)
    at com.myproject.module.MyProject.anotherMethod(MyProject.java:14)
    at com.myproject.module.MyProject.someMethod(MyProject.java:10)
    at com.myproject.module.MyProject.main(MyProject.java:6)
"}]
[2] tail.0: [[1750333602.460998000, {}], {"log"=>"another line...
"}]
```
